import { App, Plugin, PluginSettingTab, Setting, Notice, TFile, MarkdownView, ItemView, WorkspaceLeaf } from 'obsidian';
import { NetworkPromptsService } from './src/core/network-prompts';

// Core modules
import { ReminderScheduler } from './src/core/scheduler';
import { TemplateEngine } from './src/core/template-engine';
import { DataManager } from './src/core/data-manager';
import { SessionManager } from './src/core/session-manager';

// Purpose-based modules
import { QaOnboardingWizard } from './src/ui/qa-onboarding-wizard';
import { QaReviewModal } from './src/ui/qa-review-modal';
import { PurposeSessionManager } from './src/core/purpose-session-manager';
import { WeeklyPlanner } from './src/core/weekly-planner';
import { ToastManager } from './src/ui/toast';
import { EstimationEngine } from './src/core/estimation-engine';
import { WritingMomentumSettingTab } from './src/ui/settings-tab';

// Types
import type { WritingMomentumSettings, WritingSession, WritingProfile, SessionLog } from './src/types/interfaces';
import { DEFAULT_SETTINGS } from './src/types/interfaces';

// Remove duplicate interfaces - using imported ones from types/interfaces.ts

const WRITING_PROMPTS = [
	// Creative Questions
	"What if gravity worked backwards for one day?",
	"Describe a world where colors have sounds",
	"What would you tell your younger self?",
	"If you could have dinner with any historical figure, who would it be and why?",
	"Describe your perfect day in vivid detail",
	
	// Reflection Questions
	"What's the most important lesson you learned recently?",
	"What are you most grateful for right now?",
	"What challenge are you currently facing and how might you overcome it?",
	"What small thing brought you joy today?",
	"What would you do if you weren't afraid?",
	
	// Story Starters
	"The old book opened itself to a page that wasn't there yesterday...",
	"She found a letter addressed to her, dated 50 years in the future...",
	"The last person on Earth sat alone in a room. There was a knock at the door...",
	"Every morning, the same stranger waves at you from their window...",
	"You wake up with the ability to hear everyone's thoughts, except one person...",
	
	// Keywords/Themes
	"Write about: Transformation",
	"Explore the theme: Hidden connections",
	"Focus on: Unexpected kindness",
	"Consider: The space between words",
	"Reflect on: Moments of change",
	
	// Observation Prompts  
	"Describe what you can see from where you're sitting",
	"What sounds do you notice right now?",
	"Write about a memory triggered by a smell",
	"Describe a person you saw today without using their appearance",
	"What's the story behind an object near you?",
	
	// Emotional Prompts
	"Write about a time you felt completely understood",
	"Describe the feeling of coming home",
	"What does hope look like to you?",
	"Write about a moment of unexpected courage",
	"Describe the weight of a secret",
	
	// Abstract Concepts
	"If time had a texture, what would it feel like?",
	"What color is Monday?",
	"Describe the personality of your favorite room",
	"What would loneliness say if it could speak?",
	"Write about the space between heartbeats"
];

const QUICK_KEYWORDS = [
	"Mystery", "Journey", "Discovery", "Connection", "Solitude", 
	"Courage", "Change", "Memory", "Hope", "Wonder",
	"Silence", "Movement", "Light", "Shadow", "Time",
	"Growth", "Healing", "Adventure", "Home", "Freedom",
	"Dreams", "Truth", "Beauty", "Strength", "Peace"
];

export default class WritingMomentumPlugin extends Plugin {
	settings: WritingMomentumSettings;
	dataManager: DataManager;
	templateEngine: TemplateEngine;
	sessionManager: SessionManager;
	reminderScheduler: ReminderScheduler;
	statusBarItem: HTMLElement | null = null;
	currentSession: WritingSession | null = null;
	sessionHistory: WritingSession[] = []; // Made public for dashboard access
	private wordCountInterval: number | null = null;
	randomPrompts: NetworkPromptsService;
	isMobile: boolean = false;

	// Purpose-based system
	purposeSessionManager: PurposeSessionManager | null = null;
	toastManager: ToastManager;
	activeProfile: WritingProfile | null = null;
	sessionLogs: SessionLog[] = [];
	private nudgeInterval: number | null = null;

	async onload() {
		// Detect mobile platform
		this.isMobile = (this.app as any).isMobile || false;

		// Load settings and session history
		await this.loadSettings();
		await this.loadSessionHistory();

		// Initialize core systems
		this.dataManager = new DataManager(this);
		this.templateEngine = new TemplateEngine(this);
		this.sessionManager = new SessionManager(this);
		this.reminderScheduler = new ReminderScheduler(this);

		await this.dataManager.loadData();
		await this.templateEngine.initialize();

		// Initialize random prompts service
		this.randomPrompts = new NetworkPromptsService(this);

		// Auto-refresh random prompts if enabled
		if (this.settings.randomPrompts.enabled && this.settings.randomPrompts.autoRefresh) {
			// Fetch prompts in background (don't await to avoid blocking startup)
			this.randomPrompts.fetchNetworkPrompts().catch(() => {
				// Background fetch failed - continue silently
			});
		}

		// Initialize purpose-based system
		this.toastManager = new ToastManager();
		await this.loadPurposeData();

		// Check if user needs onboarding
		if (!this.activeProfile) {
			// Show Q&A onboarding wizard for new users
			new QaOnboardingWizard(this.app, async (profile) => {
				this.activeProfile = profile;
				await this.savePurposeData();

				// Initialize purpose session manager with profile
				this.purposeSessionManager = new PurposeSessionManager(this);
				this.purposeSessionManager.setActiveProfile(profile);

				// Start weekly nudge scheduler
				this.startNudgeScheduler();

				// Show confirmation with recommendation
				const rec = EstimationEngine.describe(profile.recommendation);
				this.toastManager.success(`Profile created! Defaults set: ${rec}`, 5000);
			}).open();
		} else {
			// Existing user - initialize purpose session manager
			this.purposeSessionManager = new PurposeSessionManager(this);
			this.purposeSessionManager.setActiveProfile(this.activeProfile);

			// Start weekly nudge scheduler
			this.startNudgeScheduler();
		}

		// Register dashboard view
		this.registerView(
			VIEW_TYPE_WRITING_DASHBOARD,
			(leaf) => new WritingDashboard(leaf, this)
		);

		// Add ribbon icon (always show on mobile for easy access)
		if (this.settings.ui.showRibbonIcon || this.isMobile) {
			this.addRibbonIcon('target', 'Writing Momentum', () => {
				this.openDashboard();
			});
		}

		// Add status bar
		if (this.settings.ui.showStatusBar) {
			this.statusBarItem = this.addStatusBarItem();
			this.updateStatusBar();
		}

		// Add commands
		this.addCommand({
			id: 'open-dashboard',
			name: 'Open Dashboard',
			callback: () => this.openDashboard()
		});

		this.addCommand({
			id: 'start-writing-session',
			name: 'Start Session',
			callback: () => this.startQuickSession()
		});

		this.addCommand({
			id: 'complete-session',
			name: 'Complete Session',
			callback: () => this.completeSession()
		});

		this.addCommand({
			id: 'quick-note',
			name: 'Create Quick Note',
			callback: () => this.createQuickNote()
		});

		this.addCommand({
			id: 'insert-writing-prompt',
			name: 'Insert Prompt',
			callback: () => this.insertWritingPrompt()
		});

		this.addCommand({
			id: 'stop-all-timers',
			name: 'Stop All Timers and Alarms',
			callback: () => this.stopAllTimers()
		});

		// Purpose-based commands
		this.addCommand({
			id: 'wm-start-purpose-session',
			name: 'WM: Start Writing Session',
			callback: () => {
				const file = this.app.workspace.getActiveFile();
				if (file && this.purposeSessionManager) {
					this.purposeSessionManager.startSession(file.path);
				} else if (!file) {
					this.toastManager.warn('Please open a file to start a session');
				}
			}
		});

		this.addCommand({
			id: 'wm-pause-session',
			name: 'WM: Pause Session',
			callback: () => {
				if (this.purposeSessionManager) {
					this.purposeSessionManager.pauseSession();
				}
			}
		});

		this.addCommand({
			id: 'wm-resume-session',
			name: 'WM: Resume Session',
			callback: () => {
				if (this.purposeSessionManager) {
					this.purposeSessionManager.resumeSession();
				}
			}
		});

		this.addCommand({
			id: 'wm-complete-session',
			name: 'WM: Complete Session',
			callback: () => {
				if (this.purposeSessionManager) {
					this.purposeSessionManager.completeSession();
				}
			}
		});

		this.addCommand({
			id: 'wm-skip-session',
			name: 'WM: Skip Session',
			callback: () => {
				if (this.purposeSessionManager) {
					this.purposeSessionManager.skipSession();
				}
			}
		});

		this.addCommand({
			id: 'wm-weekly-summary',
			name: 'WM: Show Weekly Summary',
			callback: () => {
				if (this.activeProfile) {
					const planner = new WeeklyPlanner(
						this.activeProfile,
						this.sessionLogs,
						this.toastManager
					);
					planner.showWeeklySummary();
				}
			}
		});

		this.addCommand({
			id: 'wm-run-onboarding',
			name: 'WM: Re-run Onboarding',
			callback: () => {
				new QaOnboardingWizard(this.app, async (profile) => {
					this.activeProfile = profile;
					await this.savePurposeData();

					if (this.purposeSessionManager) {
						this.purposeSessionManager.setActiveProfile(profile);
					}

					const rec = EstimationEngine.describe(profile.recommendation);
					this.toastManager.success(`Profile updated! ${rec}`, 4000);
				}).open();
			}
		});

		this.addCommand({
			id: 'wm-view-qa-answers',
			name: 'WM: View Q&A Answers',
			callback: () => {
				if (!this.activeProfile) {
					this.toastManager.warn('No profile found. Please run onboarding first.');
					return;
				}

				new QaReviewModal(
					this.app,
					this.activeProfile,
					() => {
						// Edit callback - reopen onboarding
						new QaOnboardingWizard(this.app, async (profile) => {
							this.activeProfile = profile;
							await this.savePurposeData();

							if (this.purposeSessionManager) {
								this.purposeSessionManager.setActiveProfile(profile);
							}

							this.toastManager.success('Answers updated!', 3000);
						}).open();
					},
					async (newRec) => {
						// Recalculate callback
						if (this.activeProfile) {
							this.activeProfile.recommendation = newRec;
							this.activeProfile.updatedAt = Date.now();
							await this.savePurposeData();

							const rec = EstimationEngine.describe(newRec);
							this.toastManager.success(`Defaults recalculated: ${rec}`, 4000);
						}
					}
				).open();
			}
		});

		this.addCommand({
			id: 'wm-recalculate-defaults',
			name: 'WM: Recalculate Defaults',
			callback: async () => {
				if (!this.activeProfile) {
					this.toastManager.warn('No profile found. Please run onboarding first.');
					return;
				}

				const newRec = EstimationEngine.estimate(this.activeProfile.answers);
				this.activeProfile.recommendation = newRec;
				this.activeProfile.updatedAt = Date.now();
				// Clear overrides when recalculating
				this.activeProfile.overrides = undefined;
				await this.savePurposeData();

				const rec = EstimationEngine.describe(newRec);
				this.toastManager.success(`Defaults recalculated: ${rec}`, 4000);
			}
		});

		// Add settings tab
		this.addSettingTab(new WritingMomentumSettingTab(this.app, this));

		// Listen for file changes
		this.registerEvent(
			this.app.workspace.on('file-open', (file) => {
				if (file && file.extension === 'md') {
					this.checkAutoStartSession(file);
				}
			})
		);

	}

	onunload() {
		this.stopAllTimers();

		// Clean up purpose-based managers
		if (this.purposeSessionManager) {
			this.purposeSessionManager.destroy();
		}
		if (this.toastManager) {
			this.toastManager.cleanup();
		}
		if (this.nudgeInterval) {
			window.clearInterval(this.nudgeInterval);
		}
	}

	stopAllTimers() {
		// Stop word count tracking interval
		if (this.wordCountInterval) {
			window.clearInterval(this.wordCountInterval);
			this.wordCountInterval = null;
		}

		// Stop dashboard real-time updates
		const dashboardViews = this.app.workspace.getLeavesOfType(VIEW_TYPE_WRITING_DASHBOARD);
		dashboardViews.forEach(leaf => {
			const view = leaf.view as WritingDashboard;
			if (view && view.stopRealTimeUpdates) {
				view.stopRealTimeUpdates();
			}
		});

		// Complete any active sessions to stop their timers
		if (this.currentSession && this.currentSession.active) {
			this.completeSession();
		}
		// new Notice('All writing timers and alarms stopped');
	}

	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}

	// Purpose-based data management
	async loadPurposeData() {
		const data = await this.loadData() as any;
		this.activeProfile = data.writingProfile || null;
		this.sessionLogs = data.sessionLogs || [];
	}

	async savePurposeData() {
		const data = await this.loadData() as any;
		data.writingProfile = this.activeProfile;
		data.sessionLogs = this.sessionLogs;
		await this.saveData(data);
	}

	// Weekly nudge scheduler
	startNudgeScheduler() {
		if (this.nudgeInterval) {
			window.clearInterval(this.nudgeInterval);
		}

		// Check for nudges every 15 minutes
		this.nudgeInterval = window.setInterval(() => {
			if (!this.activeProfile) return;

			const planner = new WeeklyPlanner(
				this.activeProfile,
				this.sessionLogs,
				this.toastManager
			);

			if (planner.shouldNudge()) {
				planner.showNudge();
			}
		}, 60000 * 15); // 15 minutes

		this.registerInterval(this.nudgeInterval);
	}

	refreshDashboard() {
		// Find and refresh the dashboard if it's open
		const {workspace} = this.app;
		const dashboardLeaves = workspace.getLeavesOfType(VIEW_TYPE_WRITING_DASHBOARD);

		if (dashboardLeaves.length > 0) {
			// Get the dashboard view and refresh it
			const dashboardLeaf = dashboardLeaves[0];
			const dashboardView = dashboardLeaf.view as WritingDashboard;
			if (dashboardView && dashboardView.render) {
				dashboardView.render();
			}
		}
	}

	async loadSessionHistory() {
		const data = await this.loadData();
		if (data?.sessionHistory) {
			this.sessionHistory = data.sessionHistory;
		}
	}

	async saveSessionHistory() {
		const currentData = await this.loadData() || {};
		currentData.sessionHistory = this.sessionHistory;
		await this.saveData(currentData);
	}

	getRandomPrompt(): string {
		// Use random prompts if enabled
		if (this.settings.randomPrompts.enabled && this.randomPrompts) {
			const randomPrompt = this.randomPrompts.getRandomNetworkPrompt();

			if (randomPrompt) {
				// If mixing with local prompts, randomly choose between random and local
				if (this.settings.randomPrompts.mixWithLocal && Math.random() < 0.5) {
					return WRITING_PROMPTS[Math.floor(Math.random() * WRITING_PROMPTS.length)];
				}
				return randomPrompt;
			}
		}

		// Fallback to local prompts
		return WRITING_PROMPTS[Math.floor(Math.random() * WRITING_PROMPTS.length)];
	}

	getRandomKeyword(): string {
		return QUICK_KEYWORDS[Math.floor(Math.random() * QUICK_KEYWORDS.length)];
	}

	// Dashboard Management
	async openDashboard() {
		const { workspace } = this.app;

		let leaf = workspace.getLeavesOfType(VIEW_TYPE_WRITING_DASHBOARD)[0];

		if (!leaf) {
			// On mobile, use the main leaf; on desktop, use right sidebar
			if (this.isMobile) {
				leaf = workspace.getLeaf(false);
			} else {
				const rightLeaf = workspace.getRightLeaf(false);
				if (rightLeaf) {
					leaf = rightLeaf;
				}
			}

			if (leaf) {
				await leaf.setViewState({ type: VIEW_TYPE_WRITING_DASHBOARD, active: true });
			}
		}

		if (leaf) {
			workspace.revealLeaf(leaf);
		}
	}

	// Session Management
	startQuickSession() {
		const activeFile = this.app.workspace.getActiveFile();
		if (!activeFile) {
			// new Notice('No active file to start session with');
			return;
		}

		if (this.currentSession) {
			// new Notice('Session already active');
			return;
		}

		this.currentSession = {
			id: `session-${Date.now()}`,
			startTime: Date.now(),
			wordCount: 0,
			active: true,
			paused: false,
			totalPausedDuration: 0,
			filePath: activeFile.path,
			date: new Date().toISOString().split('T')[0],
			files: [activeFile.path],
			completed: false
		};

		// Start monitoring word count
		this.startWordCountTracking();
		
		if (this.settings.enableNotifications) {
			// new Notice('Writing session started! ðŸ“');
		}

		this.updateStatusBar();
		this.refreshDashboard();
	}

	completeSession() {
		if (!this.currentSession) {
			// new Notice('No active session to complete');
			return;
		}

		this.currentSession.active = false;
		this.currentSession.endTime = Date.now();
		const duration = Math.round((Date.now() - this.currentSession.startTime) / 60000);

		// Save to history
		this.sessionHistory.push({...this.currentSession});
		this.saveSessionHistory();

		if (this.settings.enableNotifications) {
			const message = `Session completed! ${this.currentSession.wordCount} words in ${duration} minutes ðŸŽ‰`;
			// new Notice(message);
		}

		// Stop tracking
		if (this.wordCountInterval) {
			window.clearInterval(this.wordCountInterval);
			this.wordCountInterval = null;
		}

		this.currentSession = null;
		this.updateStatusBar();

		// Refresh dashboard to show updated continuous writing progress
		this.refreshDashboard();
	}

	pauseSession() {
		if (!this.currentSession || !this.currentSession.active || this.currentSession.paused) {
			// new Notice('No active session to pause');
			return;
		}

		this.currentSession.paused = true;
		this.currentSession.pausedTime = Date.now();

		// Stop word count tracking
		if (this.wordCountInterval) {
			window.clearInterval(this.wordCountInterval);
			this.wordCountInterval = null;
		}

		if (this.settings.enableNotifications) {
			// new Notice('Session paused â¸ï¸');
		}

		this.updateStatusBar();
	}

	resumeSession() {
		if (!this.currentSession || !this.currentSession.active || !this.currentSession.paused) {
			// new Notice('No paused session to resume');
			return;
		}

		// Add the paused duration to total
		if (this.currentSession.pausedTime) {
			this.currentSession.totalPausedDuration! += Date.now() - this.currentSession.pausedTime;
		}

		this.currentSession.paused = false;
		this.currentSession.pausedTime = undefined;

		// Restart word count tracking
		this.startWordCountTracking();

		if (this.settings.enableNotifications) {
			// new Notice('Session resumed â–¶ï¸');
		}

		this.updateStatusBar();
	}

	private startWordCountTracking() {
		if (this.wordCountInterval) {
			window.clearInterval(this.wordCountInterval);
		}

		this.wordCountInterval = window.setInterval(() => {
			this.updateWordCount();
		}, 5000);

		this.registerInterval(this.wordCountInterval);
	}

	private async updateWordCount() {
		if (!this.currentSession) return;

		const file = this.app.vault.getAbstractFileByPath(this.currentSession.filePath!);
		if (file instanceof TFile) {
			try {
				const content = await this.app.vault.read(file);
				const wordCount = this.countWords(content);
				this.currentSession.wordCount = wordCount;
				this.updateStatusBar();
			} catch (error) {
				// Failed to read file, continue silently
			}
		}
	}

	private countWords(text: string): number {
		// Remove frontmatter
		const withoutFrontmatter = text.replace(/^---[\s\S]*?---\n?/, '');
		// Count words
		return withoutFrontmatter.trim().split(/\s+/).filter(word => word.length > 0).length;
	}

	private updateStatusBar() {
		if (!this.statusBarItem) return;

		if (this.currentSession && this.currentSession.active) {
			let effectiveDuration = Date.now() - this.currentSession.startTime - (this.currentSession.totalPausedDuration || 0);
			
			// If currently paused, don't include the current pause time
			if (this.currentSession.paused && this.currentSession.pausedTime) {
				effectiveDuration -= (Date.now() - this.currentSession.pausedTime);
			}
			
			const duration = Math.round(effectiveDuration / 60000);
			const pauseIndicator = this.currentSession.paused ? ' â¸ï¸' : '';
			this.statusBarItem.setText(`âœï¸ ${this.currentSession.wordCount} words (${duration}m)${pauseIndicator}`);
		} else {
			this.statusBarItem.setText('ðŸ“ Ready to write');
		}
	}

	private checkAutoStartSession(file: TFile) {
		// Auto-start session logic disabled to prevent intrusive notices
		return;
	}

	async createQuickNote() {
		const now = new Date();
		const dateStr = now.toISOString().split('T')[0];
		// Use safe time format without colons for file names
		const timeStr = now.toLocaleTimeString('en-US', { 
			hour: '2-digit', 
			minute: '2-digit', 
			hour12: false 
		}).replace(/:/g, '-'); // Replace colons with dashes
		
		const fileName = `${dateStr} Quick Note ${timeStr}.md`;
		const displayTime = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
		const content = `# Quick Note - ${dateStr}\n\nWhat's on your mind?\n\n---\n\nWritten at ${displayTime}`;

		try {
			// Check if file already exists, if so append a number
			let uniqueFileName = fileName;
			let counter = 1;
			while (this.app.vault.getAbstractFileByPath(uniqueFileName)) {
				const baseName = fileName.replace('.md', '');
				uniqueFileName = `${baseName} (${counter}).md`;
				counter++;
			}

			const file = await this.app.vault.create(uniqueFileName, content);
			const leaf = this.app.workspace.getLeaf();
			await leaf.openFile(file);
			
			if (this.settings.enableNotifications) {
				// new Notice(`Quick note created: ${file.name}`);
			}
			
			// Auto-start session after a brief delay
			setTimeout(() => this.startQuickSession(), 100);
		} catch (error) {
			new Notice(`Failed to create quick note: ${error.message}`);
		}
	}

	async createTemplateNoteAndStartSession() {
		// Show template selection dialog
		const selectedTemplate = await this.showTemplateSelectionDialog();
		if (!selectedTemplate) {
			return; // User cancelled
		}

		try {
			// Process the title pattern
			const title = this.processTemplate(selectedTemplate.title);

			// Process the template content
			const content = this.processTemplate(selectedTemplate.template, title);

			// Create safe file name (remove invalid characters)
			const safeFileName = this.sanitizeFileName(title) + '.md';

			// Check if file already exists, if so append a number
			let uniqueFileName = safeFileName;
			let counter = 1;
			while (this.app.vault.getAbstractFileByPath(uniqueFileName)) {
				const baseName = safeFileName.replace('.md', '');
				uniqueFileName = `${baseName} (${counter}).md`;
				counter++;
			}

			// Create the file
			const file = await this.app.vault.create(uniqueFileName, content);

			// Open the file
			const leaf = this.app.workspace.getLeaf();
			await leaf.openFile(file);

			// Start the session after a brief delay to ensure file is active
			setTimeout(() => {
				this.startQuickSession();
			}, 100);

			if (this.settings.enableNotifications) {
				// new Notice(`Session started with: ${file.name}`);
			}
		} catch (error) {
			new Notice(`Failed to create note: ${error.message}`);
		}
	}

	private processTemplate(template: string, customTitle?: string): string {
		const now = new Date();
		const dateStr = now.toISOString().split('T')[0];
		const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
		const weekdayStr = now.toLocaleDateString('en-US', { weekday: 'long' });
		const randomPrompt = this.getRandomPrompt();

		let processed = template
			.replace(/\{\{date\}\}/g, dateStr)
			.replace(/\{\{time\}\}/g, timeStr)
			.replace(/\{\{weekday\}\}/g, weekdayStr)
			.replace(/\{\{vault\}\}/g, this.app.vault.getName())
			.replace(/\{\{random_prompt\}\}/g, randomPrompt);

		// Handle title - use custom title if provided, otherwise use processed title pattern
		if (customTitle) {
			processed = processed.replace(/\{\{title\}\}/g, customTitle);
		} else {
			// If no custom title and we're processing the title pattern itself, use a default
			processed = processed.replace(/\{\{title\}\}/g, 'Writing Session');
		}

		return processed;
	}

	private sanitizeFileName(fileName: string): string {
		// Remove or replace invalid file name characters
		return fileName.replace(/[<>:"/\\|?*]/g, '-').replace(/\s+/g, ' ').trim();
	}

	private async showTemplateSelectionDialog(): Promise<{name: string, title: string, template: string} | null> {
		return new Promise((resolve) => {
			const templates = this.getAvailableTemplates();

			// Create modal
			const modal = document.createElement('div');
			modal.className = 'template-modal-container';

			const dialog = document.createElement('div');
			dialog.className = 'template-selection-dialog';

			// Create header
			const header = dialog.createEl('h2', { text: 'Choose Writing Template' });
			const description = dialog.createEl('p', { text: 'Select a template to start your writing session:' });
			const optionsContainer = dialog.createEl('div', { cls: 'template-options' });
			const buttonsContainer = dialog.createEl('div', { cls: 'template-dialog-buttons' });
			const cancelBtn = buttonsContainer.createEl('button', { text: 'Cancel', cls: 'cancel-btn' });

			templates.forEach((template, index) => {
				const option = optionsContainer.createEl('div', { cls: 'template-option' });

				const templateName = option.createEl('h3', { text: template.name });
				const templateDesc = option.createEl('p', { text: template.description });

				option.addEventListener('click', () => {
					document.body.removeChild(modal);
					resolve(template);
				});
			});

			cancelBtn.addEventListener('click', () => {
				document.body.removeChild(modal);
				resolve(null);
			});

			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					document.body.removeChild(modal);
					resolve(null);
				}
			});

			modal.appendChild(dialog);
			document.body.appendChild(modal);
		});
	}

	private getAvailableTemplates() {
		return [
			{
				name: 'Daily Journal',
				description: 'Structured daily reflection with prompts for events, feelings, and gratitude',
				title: '{{date}} - Daily Journal',
				template: `**ðŸ“ Today's Writing Session**
*Take a moment to reflect on your day and capture your thoughts.*

## Morning Reflection
{{random_prompt}}

## Today's Events
-
-
-

## Thoughts & Feelings


## Gratitude
1.
2.
3.

---
*Journal entry for {{weekday}}, {{date}} at {{time}}*`
			},
			{
				name: 'Creative Writing',
				description: 'Free-form creative writing with inspiration prompt',
				title: '{{date}} - Creative Writing',
				template: `**âœ¨ Creative Writing Session**
*Let your imagination flow and create something beautiful.*

## Writing Prompt
{{random_prompt}}

## Your Story


---
*Creative session on {{weekday}} at {{time}}*`
			},
			{
				name: 'Quick Notes',
				description: 'Fast idea capture and organization',
				title: '{{time}} - Quick Note',
				template: `**ðŸ’¡ Quick Idea Capture**
*Capture your thoughts quickly and organize them for later.*

## Main Idea
{{random_prompt}}

## Details


## Next Steps
- [ ]
- [ ]

---
*Note taken {{weekday}} at {{time}}*`
			},
			{
				name: 'Project Planning',
				description: 'Structured project planning and task organization',
				title: '{{date}} - Project Planning',
				template: `**ðŸŽ¯ Project Planning Session**
*Plan your project systematically and set clear goals.*

## Project Goal
{{random_prompt}}

## Overview
**Start Date:** {{date}}
**Status:** Planning

## Tasks
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## Timeline


## Resources


---
*Project planned on {{weekday}}, {{date}} at {{time}}*`
			},
			{
				name: 'Free Writing',
				description: 'Unstructured writing for stream of consciousness',
				title: '{{date}} - Free Writing',
				template: `**ðŸŒŠ Free Writing Session**
*Write without stopping, let your thoughts flow naturally.*

## Starting Thought
{{random_prompt}}

## Stream of Consciousness
Write continuously for your target time. Don't worry about grammar, structure, or making sense. Just let your thoughts flow onto the page.




---
*Free writing session {{weekday}} at {{time}}*`
			}
		];
	}

	async insertWritingPrompt() {
		const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
		if (!activeView) {
			new Notice('No active note to insert prompt into');
			return;
		}

		const prompt = this.getRandomPrompt();
		const keywords = [this.getRandomKeyword(), this.getRandomKeyword(), this.getRandomKeyword()];
		const textToInsert = `**Writing Prompt:** ${prompt}\n\n**Keywords:** ${keywords.join(', ')}\n\n---\n\n`;

		const editor = activeView.editor;
		const cursor = editor.getCursor();
		editor.replaceRange(textToInsert, cursor);
		
		// Position cursor after the inserted text
		const lines = textToInsert.split('\n').length;
		editor.setCursor(cursor.line + lines - 1, 0);

		if (this.settings.enableNotifications) {
			// new Notice('Writing prompt inserted! âœ¨');
		}
	}
}

// Settings Tab
class WritingMomentumSettingTab extends PluginSettingTab {
	plugin: WritingMomentumPlugin;

	constructor(app: App, plugin: WritingMomentumPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const {containerEl} = this;
		containerEl.empty();

		containerEl.createEl('h2', {text: 'Writing Momentum Settings'});

		// General Settings
		containerEl.createEl('h3', {text: 'General Settings'});

		// Reminder time
		new Setting(containerEl)
			.setName('Reminder time')
			.setDesc('Daily writing reminder (HH:MM format)')
			.addText(text => text
				.setPlaceholder('21:00')
				.setValue(this.plugin.settings.reminderTime || '21:00')
				.onChange(async (value) => {
					this.plugin.settings.reminderTime = value;
					await this.plugin.saveSettings();
				}));

		// Show status bar
		new Setting(containerEl)
			.setName('Show status bar')
			.setDesc('Display writing progress in status bar')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.showStatusBar || false)
				.onChange(async (value) => {
					this.plugin.settings.showStatusBar = value;
					await this.plugin.saveSettings();
					
					// Update status bar visibility
					if (value && !this.plugin.statusBarItem) {
						this.plugin.statusBarItem = this.plugin.addStatusBarItem();
						this.plugin['updateStatusBar']();
					} else if (!value && this.plugin.statusBarItem) {
						this.plugin.statusBarItem.remove();
						this.plugin.statusBarItem = null;
					}
				}));

		// Show ribbon icon
		new Setting(containerEl)
			.setName('Show ribbon icon')
			.setDesc('Display plugin icon in left ribbon')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.showRibbonIcon || false)
				.onChange(async (value) => {
					this.plugin.settings.showRibbonIcon = value;
					await this.plugin.saveSettings();
				}));

		// Enable notifications
		new Setting(containerEl)
			.setName('Enable notifications')
			.setDesc('Show notifications for session events')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.enableNotifications || false)
				.onChange(async (value) => {
					this.plugin.settings.enableNotifications = value;
					await this.plugin.saveSettings();
				}));

		// Random Prompts Section
		containerEl.createEl('h3', {text: 'Random Prompts'});

		const randomToggle = new Setting(containerEl)
			.setName('Enable random prompts')
			.setDesc('Fetch writing prompts from online sources (requires internet connection)')
			.addToggle(toggle => toggle
				.setValue(this.plugin.settings.randomPrompts.enabled)
				.onChange(async (value) => {
					this.plugin.settings.randomPrompts.enabled = value;
					await this.plugin.saveSettings();
					this.display(); // Refresh to show/hide additional options

					// Fetch prompts when enabled
					if (value && this.plugin.randomPrompts) {
						await this.plugin.randomPrompts.fetchNetworkPrompts();
					}
				}));

		// Only show additional random prompt options if enabled
		if (this.plugin.settings.randomPrompts.enabled) {
			new Setting(containerEl)
				.setName('Mix with local prompts')
				.setDesc('Randomly mix random prompts with built-in prompts for variety')
				.addToggle(toggle => toggle
					.setValue(this.plugin.settings.randomPrompts.mixWithLocal)
					.onChange(async (value) => {
						this.plugin.settings.randomPrompts.mixWithLocal = value;
						await this.plugin.saveSettings();
					}));

			new Setting(containerEl)
				.setName('Auto-refresh prompts')
				.setDesc('Automatically fetch new prompts daily (cached for offline use)')
				.addToggle(toggle => toggle
					.setValue(this.plugin.settings.randomPrompts.autoRefresh)
					.onChange(async (value) => {
						this.plugin.settings.randomPrompts.autoRefresh = value;
						await this.plugin.saveSettings();
					}));

			// Show prompt status and manual refresh
			const statusSetting = new Setting(containerEl)
				.setName('Prompt cache status')
				.setDesc('View and manage cached random prompts');

			const refreshBtn = statusSetting.controlEl.createEl('button', {
				text: 'Refresh Now',
				cls: 'mod-cta'
			});

			refreshBtn.onclick = async () => {
				refreshBtn.disabled = true;
				refreshBtn.textContent = 'Refreshing...';

				try {
					const success = await this.plugin.randomPrompts.refreshPrompts();
					if (success) {
						new Notice('Random prompts refreshed successfully!');
					} else {
						new Notice('Failed to refresh prompts. Check your internet connection.');
					}
				} catch (error) {
					new Notice('Error refreshing prompts: ' + error.message);
				}

				refreshBtn.disabled = false;
				refreshBtn.textContent = 'Refresh Now';
				this.updatePromptStatus(statusSetting);
			};

			this.updatePromptStatus(statusSetting);
		}

		// Template Presets Section
		containerEl.createEl('h3', {text: 'Template Presets'});

		const templates = [
			{
				name: 'Daily Journal',
				title: '{{date}} - Daily Journal',
				template: '# Daily Journal - {{date}}\n\n## Morning Reflection\n{{random_prompt}}\n\n## Today\'s Events\n- \n- \n- \n\n## Thoughts & Feelings\n\n\n## Gratitude\n1. \n2. \n3. \n\n---\n*Written on {{weekday}} at {{time}}*'
			},
			{
				name: 'Quick Notes',
				title: '{{time}} - Quick Note',
				template: '# Quick Note\n\n## Idea\n{{random_prompt}}\n\n## Details\n\n\n## Next Steps\n- [ ] \n- [ ] \n\n---\n*{{weekday}} {{time}}*'
			},
			{
				name: 'Project Planning',
				title: 'Project - {{title}}',
				template: '# Project: {{title}}\n\n## Goal\n{{random_prompt}}\n\n## Overview\n**Start Date:** {{date}}\n**Status:** Planning\n\n## Tasks\n- [ ] Task 1\n- [ ] Task 2\n- [ ] Task 3\n\n## Timeline\n\n\n## Resources\n\n\n---\n*Created {{weekday}}, {{date}} at {{time}}*'
			}
		];

		let titleInput: HTMLInputElement;
		let templateTextarea: HTMLTextAreaElement;

		new Setting(containerEl)
			.setName('Template preset')
			.setDesc('Choose a template to customize')
			.addDropdown(dropdown => {
				dropdown.addOption('custom', 'Custom Template');
				templates.forEach((template, index) => {
					dropdown.addOption(index.toString(), template.name);
				});

				// Set current value based on settings
				const currentTemplate = templates.find(t =>
					t.title === this.plugin.settings.defaultTitlePattern &&
					t.template === this.plugin.settings.defaultTemplate
				);
				dropdown.setValue(currentTemplate ? templates.indexOf(currentTemplate).toString() : 'custom');

				dropdown.onChange((value) => {
					if (value === 'custom') return;

					const selectedTemplate = templates[parseInt(value)];
					this.plugin.settings.defaultTitlePattern = selectedTemplate.title;
					this.plugin.settings.defaultTemplate = selectedTemplate.template;
					this.plugin.saveSettings();

					// Refresh the display to update all fields
					this.display();
				});
			});


		// Page Title Pattern Editor (Full Width) - moved to bottom
		containerEl.createEl('br');
		containerEl.createEl('h3', {text: 'Page Title Pattern'});

		const titlePatternContainer = containerEl.createDiv('title-pattern-container');
		titlePatternContainer.createEl('p', {
			text: 'Pattern for new page titles. Use variables like {{date}}, {{time}}, {{title}}, etc.',
			cls: 'title-pattern-description'
		});

		titleInput = titlePatternContainer.createEl('input', {
			cls: 'title-pattern-editor',
			attr: {
				type: 'text',
				placeholder: '{{date}} - Writing Session'
			}
		});

		titleInput.value = this.plugin.settings.defaultTitlePattern || '{{date}} - Writing Session';

		titleInput.addEventListener('input', async () => {
			this.plugin.settings.defaultTitlePattern = titleInput.value;
			await this.plugin.saveSettings();
		});

		// Template Content Editor (Full Width) - moved to bottom
		containerEl.createEl('h3', {text: 'Template Content Editor'});

		const templateContentContainer = containerEl.createDiv('template-content-container');
		templateContentContainer.createEl('p', {
			text: 'Edit your template content below. Use variables like {{date}}, {{time}}, {{random_prompt}}, etc.',
			cls: 'template-content-description'
		});

		templateTextarea = templateContentContainer.createEl('textarea', {
			cls: 'template-content-editor',
			attr: {
				placeholder: '# {{title}}\n\n## Prompt\n{{random_prompt}}\n\n## Writing\n\n\n---\n*Written on {{weekday}} at {{time}}*'
			}
		});

		templateTextarea.value = this.plugin.settings.defaultTemplate || '# {{title}}\n\n## Prompt\n{{random_prompt}}\n\n## Writing\n\n\n---\n*Written on {{weekday}} at {{time}}*';

		templateTextarea.addEventListener('input', async () => {
			this.plugin.settings.defaultTemplate = templateTextarea.value;
			await this.plugin.saveSettings();
		});

	}

	private refreshDashboard() {
		// Find and refresh the dashboard if it's open
		const {workspace} = this.app;
		const dashboardLeaves = workspace.getLeavesOfType(VIEW_TYPE_WRITING_DASHBOARD);

		if (dashboardLeaves.length > 0) {
			// Get the dashboard view and refresh it
			const dashboardLeaf = dashboardLeaves[0];
			const dashboardView = dashboardLeaf.view as WritingDashboard;
			if (dashboardView && dashboardView.render) {
				dashboardView.render();
			}
		}
	}

	private updatePromptStatus(statusSetting: Setting) {
		if (!this.plugin.randomPrompts) return;

		const count = this.plugin.randomPrompts.getCachedPromptsCount();
		const lastFetch = this.plugin.randomPrompts.getLastFetchTime();

		let statusText = `${count} prompts cached`;
		if (lastFetch) {
			const timeAgo = this.getTimeAgo(lastFetch);
			statusText += ` (last updated ${timeAgo})`;
		} else {
			statusText += ' (never fetched)';
		}

		statusSetting.setDesc(statusText);
	}

	private getTimeAgo(date: Date): string {
		const now = new Date();
		const diffMs = now.getTime() - date.getTime();
		const diffMins = Math.floor(diffMs / (1000 * 60));
		const diffHours = Math.floor(diffMins / 60);
		const diffDays = Math.floor(diffHours / 24);

		if (diffMins < 1) return 'just now';
		if (diffMins < 60) return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
		if (diffHours < 24) return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
		return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
	}
}

// Dashboard View
const VIEW_TYPE_WRITING_DASHBOARD = 'writing-momentum-dashboard';

class WritingDashboard extends ItemView {
	private plugin: WritingMomentumPlugin;
	private updateInterval: number | null = null;

	constructor(leaf: WorkspaceLeaf, plugin: WritingMomentumPlugin) {
		super(leaf);
		this.plugin = plugin;
	}

	getViewType(): string {
		return VIEW_TYPE_WRITING_DASHBOARD;
	}

	getDisplayText(): string {
		return 'Writing Dashboard';
	}

	getIcon(): string {
		return 'target';
	}

	async onOpen() {
		this.render();
		this.startRealTimeUpdates();
	}

	async onClose() {
		this.stopRealTimeUpdates();
	}

	private startRealTimeUpdates() {
		// Update every second for real-time timer
		this.updateInterval = window.setInterval(() => {
			this.updateRealTimeElements();
		}, 1000);

		// Register cleanup with Obsidian
		this.plugin.registerInterval(this.updateInterval);
	}

	stopRealTimeUpdates() {
		if (this.updateInterval) {
			window.clearInterval(this.updateInterval);
			this.updateInterval = null;
		}
	}

	private updateRealTimeElements() {
		// Update current session timer if active
		const timerElement = this.containerEl.querySelector('.session-timer');
		if (timerElement && this.plugin.currentSession && this.plugin.currentSession.active) {
			const session = this.plugin.currentSession;

			// Calculate effective duration (excluding paused time)
			let effectiveDuration = Date.now() - session.startTime - (session.totalPausedDuration || 0);
			if (session.paused && session.pausedTime) {
				effectiveDuration -= (Date.now() - session.pausedTime);
			}

			const hours = Math.floor(effectiveDuration / 3600000);
			const minutes = Math.floor((effectiveDuration % 3600000) / 60000);
			const seconds = Math.floor((effectiveDuration % 60000) / 1000);

			const timeString = hours > 0
				? `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
				: `${minutes}:${seconds.toString().padStart(2, '0')}`;

			timerElement.textContent = timeString;
		}

		// Update word count if needed
		const wordCountElement = this.containerEl.querySelector('.session-words');
		if (wordCountElement && this.plugin.currentSession && this.plugin.currentSession.active) {
			wordCountElement.textContent = this.plugin.currentSession.wordCount.toString();
		}
	}

	render() {
		const container = this.containerEl.children[1];
		container.empty();
		container.addClass('writing-momentum-dashboard');

		// Add mobile class if on mobile
		if (this.plugin.isMobile) {
			container.addClass('is-mobile');
		}

		// Header
		const header = container.createEl('div', { cls: 'dashboard-header' });
		header.createEl('h2', { text: 'Writing Dashboard', cls: 'dashboard-title' });

		// Current Session
		this.renderCurrentSession(container);

		// Only show Writing Mode when no session is active
		const hasActiveSession = this.plugin.currentSession && this.plugin.currentSession.active;

		if (!hasActiveSession) {
			this.renderWritingMode(container);
		}

		// Writing Volume Charts
		this.renderWritingVolumeChart(container);
	}

	private renderCurrentSession(container: Element) {
		const sessionEl = container.createEl('div', { cls: 'dashboard-section' });
		
		if (this.plugin.currentSession && this.plugin.currentSession.active) {
			const session = this.plugin.currentSession;
			
			// Calculate effective duration (excluding paused time)
			let effectiveDuration = Date.now() - session.startTime - (session.totalPausedDuration || 0);
			if (session.paused && session.pausedTime) {
				effectiveDuration -= (Date.now() - session.pausedTime);
			}
			const duration = Math.round(effectiveDuration / 60000);
			
			// Add pause indicator to header
			const sessionHeader = sessionEl.createEl('h3', { 
				text: session.paused ? 'ðŸŽ¯ Current Session (Paused)' : 'ðŸŽ¯ Current Session'
			});
			if (session.paused) {
				sessionHeader.addClass('paused-session');
			}
			
			const statsEl = sessionEl.createEl('div', { cls: 'session-stats-grid' });
			
			const wordEl = statsEl.createEl('div', { cls: 'stat-card' });
			wordEl.createEl('span', { text: 'ðŸ“', cls: 'stat-icon' });
			wordEl.createEl('span', { text: session.wordCount.toString(), cls: 'stat-value session-words' });
			wordEl.createEl('span', { text: 'Words', cls: 'stat-label' });

			const timeEl = statsEl.createEl('div', { cls: 'stat-card' });
			timeEl.createEl('span', { text: 'â±ï¸', cls: 'stat-icon' });
			// Calculate initial timer display
			const hours = Math.floor(effectiveDuration / 3600000);
			const minutes = Math.floor((effectiveDuration % 3600000) / 60000);
			const seconds = Math.floor((effectiveDuration % 60000) / 1000);
			const timeString = hours > 0
				? `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
				: `${minutes}:${seconds.toString().padStart(2, '0')}`;
			timeEl.createEl('span', { text: timeString, cls: 'stat-value session-timer' });
			timeEl.createEl('span', { text: 'Time', cls: 'stat-label' });
			
			const fileEl = statsEl.createEl('div', { cls: 'current-file' });
			fileEl.createEl('span', { text: 'ðŸ“„ ' + (session.filePath?.split('/').pop() || 'Unknown file') });
			
			// Writing inspiration section
			const inspirationEl = sessionEl.createEl('div', { cls: 'writing-inspiration' });
			this.renderWritingInspiration(inspirationEl);
			
			const actionsEl = sessionEl.createEl('div', { cls: 'session-actions' });
			
			const completeBtn = actionsEl.createEl('button', { 
				text: 'âœ… Complete Session',
				cls: 'session-btn complete-btn'
			});
			completeBtn.onclick = () => {
				this.plugin.completeSession();
				this.render();
			};
		} else {
			sessionEl.createEl('p', { 
				text: 'ðŸ’¤ No active session. Open a markdown file and click the ribbon icon to start!',
				cls: 'no-session-message'
			});
		}
	}

	private renderWritingInspiration(container: Element) {
		const promptCard = container.createEl('div', { cls: 'prompt-card' });
		
		// Header with refresh button
		const promptHeader = promptCard.createEl('div', { cls: 'prompt-header' });
		promptHeader.createEl('span', { text: 'âœ¨ Writing Inspiration', cls: 'prompt-title' });
		
		const refreshPromptBtn = promptHeader.createEl('button', { 
			text: 'ðŸŽ²',
			cls: 'prompt-refresh-btn',
			attr: { title: 'Get new inspiration' }
		});
		
		// Main prompt
		const promptText = promptCard.createEl('div', { cls: 'prompt-text' });
		promptText.setText(this.plugin.getRandomPrompt());
		
		// Keywords section
		const keywordSection = promptCard.createEl('div', { cls: 'keyword-section' });
		keywordSection.createEl('span', { text: 'Keywords: ', cls: 'keyword-label' });
		
		const keywordContainer = keywordSection.createEl('span', { cls: 'keywords' });
		for (let i = 0; i < 3; i++) {
			const keyword = keywordContainer.createEl('span', { 
				text: this.plugin.getRandomKeyword(),
				cls: 'keyword-tag'
			});
			if (i < 2) {
				keywordContainer.createEl('span', { text: ' â€¢ ', cls: 'keyword-separator' });
			}
		}
		
		// Copy to clipboard button
		const copyBtn = promptCard.createEl('button', { 
			text: 'ðŸ“‹ Copy to Clipboard',
			cls: 'copy-prompt-btn'
		});
		
		// Event handlers
		refreshPromptBtn.onclick = () => {
			promptText.setText(this.plugin.getRandomPrompt());
			
			// Refresh keywords
			keywordContainer.empty();
			for (let i = 0; i < 3; i++) {
				const keyword = keywordContainer.createEl('span', { 
					text: this.plugin.getRandomKeyword(),
					cls: 'keyword-tag'
				});
				if (i < 2) {
					keywordContainer.createEl('span', { text: ' â€¢ ', cls: 'keyword-separator' });
				}
			}
		};
		
		copyBtn.onclick = async () => {
			const prompt = promptText.textContent || '';
			const keywords = Array.from(keywordContainer.querySelectorAll('.keyword-tag'))
				.map(el => el.textContent).join(', ');
			const textToCopy = `${prompt}\n\nKeywords: ${keywords}`;
			
			try {
				await navigator.clipboard.writeText(textToCopy);
				copyBtn.setText('âœ… Copied!');
				setTimeout(() => {
					copyBtn.setText('ðŸ“‹ Copy to Clipboard');
				}, 2000);
			} catch (error) {
				// Fallback for older browsers
				const textArea = document.createElement('textarea');
				textArea.value = textToCopy;
				document.body.appendChild(textArea);
				textArea.select();
				document.execCommand('copy');
				document.body.removeChild(textArea);
				copyBtn.setText('âœ… Copied!');
				setTimeout(() => {
					copyBtn.setText('ðŸ“‹ Copy to Clipboard');
				}, 2000);
			}
		};
	}

	private renderWritingMode(container: Element) {
		const actionsEl = container.createEl('div', { cls: 'dashboard-section' });
		actionsEl.createEl('h3', { text: 'Writing Mode' });

		const buttonsEl = actionsEl.createEl('div', { cls: 'action-buttons' });

		const startSessionBtn = buttonsEl.createEl('button', {
			text: 'ðŸš€ Start Session',
			cls: 'action-btn start-session-btn'
		});
		startSessionBtn.onclick = async () => {
			await this.plugin.createTemplateNoteAndStartSession();
			// Dashboard will refresh automatically when session starts
		};
	}


	private renderWritingVolumeChart(container: Element) {
		const chartEl = container.createEl('div', { cls: 'dashboard-section' });
		chartEl.createEl('h3', { text: 'Writing Volume' });
		
		// Create chart container
		const chartContainer = chartEl.createEl('div', { cls: 'chart-container' });
		
		// Render weekly chart
		this.renderWeeklyChart(chartContainer);
		
		// Render monthly chart
		this.renderMonthlyChart(chartContainer);
		
		// Show current totals
		this.renderVolumeTotals(chartContainer);
	}

	private renderWeeklyChart(container: Element) {
		const weeklyEl = container.createEl('div', { cls: 'weekly-chart' });
		weeklyEl.createEl('h4', { text: 'Last 7 Days' });
		
		const chartEl = weeklyEl.createEl('div', { cls: 'bar-chart' });
		
		// Get last 7 days of data
		const weeklyData = this.getWeeklyData();
		const maxWords = Math.max(...weeklyData.map(d => d.words), 100);
		
		weeklyData.forEach((day, index) => {
			const barContainer = chartEl.createEl('div', { cls: 'bar-container' });
			
			// Day label
			const dayLabel = barContainer.createEl('div', { cls: 'bar-label' });
			dayLabel.setText(day.label);
			
			// Bar
			const bar = barContainer.createEl('div', { cls: 'bar' });
			const height = Math.max((day.words / maxWords) * 100, 2); // Minimum 2% height
			// Use CSS class for height instead of inline style
			const heightPercentage = Math.min(Math.round(height / 5) * 5, 100); // Round to nearest 5
			bar.addClass(`bar-height-${heightPercentage}`);
			bar.addClass(day.words > 0 ? 'has-data' : 'no-data');
			
			// Word count tooltip
			bar.title = `${day.words} words`;
			
			// Word count label
			if (day.words > 0) {
				const wordLabel = barContainer.createEl('div', { cls: 'word-count' });
				wordLabel.setText(day.words.toString());
			}
		});
	}

	private renderMonthlyChart(container: Element) {
		const monthlyEl = container.createEl('div', { cls: 'monthly-chart' });
		monthlyEl.createEl('h4', { text: 'Last 30 Days' });
		
		const chartEl = monthlyEl.createEl('div', { cls: 'line-chart' });
		
		// Get last 30 days of data
		const monthlyData = this.getMonthlyData();
		const maxWords = Math.max(...monthlyData.map(d => d.words), 100);
		
		// Create SVG element using DOM API instead of innerHTML
		const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
		svg.setAttribute('class', 'chart-svg');
		svg.setAttribute('width', '100%');
		svg.setAttribute('height', '120');
		svg.setAttribute('viewBox', '0 0 400 120');

		// Create path for line chart
		this.createSVGPath(svg, monthlyData, maxWords);
		this.createSVGDots(svg, monthlyData, maxWords);

		chartEl.appendChild(svg);
	}

	private renderVolumeTotals(container: Element) {
		const totalsEl = container.createEl('div', { cls: 'volume-totals' });
		
		const weekTotal = this.getWeeklyData().reduce((sum, day) => sum + day.words, 0);
		const monthTotal = this.getMonthlyData().reduce((sum, day) => sum + day.words, 0);
		
		const weekCard = totalsEl.createEl('div', { cls: 'volume-card' });
		weekCard.createEl('div', { text: weekTotal.toString(), cls: 'volume-number' });
		weekCard.createEl('div', { text: 'Words This Week', cls: 'volume-label' });
		
		const monthCard = totalsEl.createEl('div', { cls: 'volume-card' });
		monthCard.createEl('div', { text: monthTotal.toString(), cls: 'volume-number' });
		monthCard.createEl('div', { text: 'Words This Month', cls: 'volume-label' });
	}

	private createSVGPath(svg: SVGElement, monthlyData: {date: string; words: number}[], maxWords: number): void {
		let pathData = '';
		monthlyData.forEach((day, index) => {
			const x = (index / (monthlyData.length - 1)) * 380 + 10;
			const y = 100 - ((day.words / maxWords) * 80);
			pathData += (index === 0 ? 'M' : 'L') + ` ${x} ${y}`;
		});

		const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		path.setAttribute('d', pathData);
		path.setAttribute('fill', 'none');
		path.setAttribute('stroke', 'var(--interactive-accent)');
		path.setAttribute('stroke-width', '2');
		path.setAttribute('class', 'chart-svg-path');
		svg.appendChild(path);
	}

	private createSVGDots(svg: SVGElement, monthlyData: {date: string; words: number}[], maxWords: number): void {
		monthlyData.forEach((day, index) => {
			if (day.words > 0) {
				const x = (index / (monthlyData.length - 1)) * 380 + 10;
				const y = 100 - ((day.words / maxWords) * 80);

				const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				circle.setAttribute('cx', x.toString());
				circle.setAttribute('cy', y.toString());
				circle.setAttribute('r', '3');
				circle.setAttribute('fill', 'var(--interactive-accent)');
				circle.setAttribute('class', 'chart-svg-circle');

				const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
				title.textContent = `${day.date}: ${day.words} words`;
				circle.appendChild(title);

				svg.appendChild(circle);
			}
		});
	}

	private getWeeklyData() {
		const data = [];
		const today = new Date();
		
		for (let i = 6; i >= 0; i--) {
			const date = new Date(today);
			date.setDate(today.getDate() - i);
			const dateStr = date.toISOString().split('T')[0];
			
			const dayWords = this.plugin.sessionHistory
				.filter(session => session.date === dateStr && session.endTime)
				.reduce((sum, session) => sum + session.wordCount, 0);
			
			data.push({
				date: dateStr,
				label: date.toLocaleDateString('en-US', { weekday: 'short' }),
				words: dayWords
			});
		}
		
		return data;
	}

	private getMonthlyData() {
		const data = [];
		const today = new Date();
		
		for (let i = 29; i >= 0; i--) {
			const date = new Date(today);
			date.setDate(today.getDate() - i);
			const dateStr = date.toISOString().split('T')[0];
			
			const dayWords = this.plugin.sessionHistory
				.filter(session => session.date === dateStr && session.endTime)
				.reduce((sum, session) => sum + session.wordCount, 0);
			
			data.push({
				date: dateStr,
				words: dayWords
			});
		}
		
		return data;
	}

	refresh() {
		this.render();
	}
}